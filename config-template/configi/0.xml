<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<dict>
    <entry key="blockstrategy">
        <dict>
            <entry key="name">
                <string>net.postchain.base.BaseBlockBuildingStrategy</string>
            </entry>
        </dict>
    </entry>
    <entry key="configurationfactory">
        <string>net.postchain.gtx.GTXBlockchainConfigurationFactory</string>
    </entry>
    <entry key="gtx">
        <dict>
            <entry key="modules">
                <array>
                    <string>net.postchain.rell.module.RellPostchainModuleFactory</string>
                    <string>net.postchain.gtx.StandardOpsGTXModule</string>
                </array>
            </entry>
            <entry key="rell">
                <dict>
                    <entry key="moduleArgs">
                        <dict>
                            <entry key="directory1">
                                <dict>
                                    <entry key="initial_provider">
                                        <bytea>03BD795ABED2B859609EAB4961F892BBA6765CFDBEBBCFB85CE6D42B0BF24FDD25</bytea>
                                    </entry>
                                </dict>
                            </entry>
                        </dict>
                    </entry>
                    <entry key="modules">
                        <array>
                            <string>directory1</string>
                        </array>
                    </entry>
                    <entry key="sources">
                        <dict>
                            <entry key="directory1/activity.rell">
                                <string>object activity_check {
	mutable last_checked: timestamp = 0;
}

entity activity_counter {
	key provider;
	mutable count : integer = 0;
}

operation update_activity_counter () {
	if (activity_check.last_checked == 0) {
		activity_check.last_checked = op_context.last_block_time;
		return;
	}
	val delta = (op_context.last_block_time - activity_check.last_checked) / 1000;
	require(delta &gt;= 86400);

	for (provider in provider_state @* { .active == true } (.provider)) {
		// if provider has at least one active node
		if (exists(node @? { .provider == provider, .active == true} limit 1)) {
			update activity_counter@ { provider} (.count += delta);
		}
	}
	activity_check.last_checked = op_context.last_block_time;
}</string>
                            </entry>
                            <entry key="directory1/anchoring.rell">
                                <string>entity anchored_block {
	key blockchain, height: integer;
	key block_rid: byte_array;
}

entity anchored_block_signer { key anchored_block, node; }

struct base_block_header {
	blockchain_rid: byte_array;
	prev_block_rid: byte_array;
	merkle_root_hash: byte_array;
	timestamp: timestamp;
	height: integer;
	dependencies: gtv;
	extra: map&lt;text, gtv&gt;;
}

function find_blockchain_configuration (blockchain, height: integer): blockchain_configuration {
    // find configuration height -- the latest height up to given height
    return (blockchain_configuration @ { blockchain , .height &lt;= height }
     (@sort_desc .height, bc=blockchain_configuration) limit 1).bc;
}

function signers_from_configuration( blockchain_configuration ): list&lt;pubkey&gt; {
	val config_dict = map&lt;text, gtv&gt;.from_gtv(gtv.from_bytes(blockchain_configuration.data));
	return list&lt;pubkey&gt;.from_gtv(config_dict["signers"]);
}

operation anchor_block (header: base_block_header, signers: list&lt;pubkey&gt;, signatures: list&lt;byte_array&gt;) {
	val blockchain = blockchain @ { header.blockchain_rid };
	val existing_ab = anchored_block @? { blockchain, header.height };
	require(not exists(existing_ab));

	val all_signers = set(signers_from_configuration(
		find_blockchain_configuration(blockchain, header.height)
	));

	val block_rid = header.hash();
	print("block rid", block_rid);

	for (i in range(0, signers.size())) {
		require(all_signers.contains(signers[i]));
		print("s", signers[i], signatures[i]);
		require(verify_signature(block_rid, signers[i], signatures[i]));
	}

	val block = create anchored_block ( blockchain, header.height, block_rid );
	for (signer in signers) {
		create anchored_block_signer(block, node @ { signer });
	}
}</string>
                            </entry>
                            <entry key="directory1/cluster.rell">
                                <string>/* Governance semantics:
 *
 * Anybody can create a cluster, but it consumes an action point.
 *
 * A cluster defines a list of providers involved in it. Each provider is supposed to contribute one node.
 * Cluster is considered operational only once every provider specified in a cluster have provided a node.
 * Cluster composition (providers) can change, operational status does not change if new provider is added.
 *
 * Cluster composition can be changed by its 'governance' voter set, they can vote to add or remove providers
 *
 * a provider can add at most one node to a cluster he is a member of. he can also replace his node.
 *
 * Cluster's deployer can add containers, specifying their resource limits. He can change limits for existing containers.
 *
 * Container deployer can deploy, update and stop blockchains in the container.
 *
 *
 * Node can belong to multiple clusters. Although it is not recommended, but permitted.
 *
 * blockchain_signer_node records are not needed for blockchains which run on a cluster, as list
 * of signer nodes can be deduced from list of nodes of a cluster.
 *
 */

 // node cluster
 entity cluster {
     key name;
     governance: voter_set; // who controls the cluster
     deployer: voter_set; // who can deploy containers
     mutable operational: boolean = false; // cluster goes operational when all providers provide a node
 }

 entity cluster_provider { key cluster, provider; }
 entity cluster_node { key cluster, node; }

//entity cluster_signer_list { key cluster_node;}

/**Adding a node to a cluster automatically makes it signer of all bc in this cluster. Only one node per provider and cluster.
 * TODO: Start as replica; once it is in sync, it will become signer.
 * (by adding it to blockchain_configuration_signers) Go thought all bcs in cluster and update their configurations with the new node. 
 * */
operation add_node_to_cluster(provider, node_pubkey: pubkey, cluster) {
	require_provider_auth_with_rl(provider);
	add_node_to_cluster_internal(provider, node @ { node_pubkey }, cluster);
	//make_node_a_replica_in_cluster(cluster, node_pubkey);
	//check if cluster now is operational, if so update the flag:
	check_operational(cluster);	
}


//Updates of cluster providers are controlled by its governor voter set.
//TODO: Change this to propose_* or propose_update_cluster_providers(...)
operation add_provider_to_cluster(me: provider, provider, cluster) {
	require_provider_auth_with_rl(me);
	require( (provider_state @ {me}.tier &gt; 0 and provider_state @ {provider}.tier == 0) or (provider_state @ {me}.system));
	create cluster_provider(cluster, provider);
}

/* When all providers have provided a node each, cluster goes operational */
function check_operational(cl: cluster) {
	val providers = cluster_provider @* {cl}.provider;
	val nodes = cluster_node @* {cl}.node;
	if (nodes.size() &gt;= providers.size()) {
		update cluster @ {cl.name} (.operational = true);
	}
}

/** Make node a replica of all bcs in a cluster */
function make_node_a_replica_in_cluster(cluster, node_pubkey: pubkey) {
	val containers = container @*{ cluster };
	for (container in containers) {
		val bcs = container_blockchain @* {container} .blockchain;
		for (bc in bcs) {
			create blockchain_replica_node (bc, node @ { node_pubkey });
		}
	}
}

/** If a provider is part of that cluster, and if provider do not already have a node in this cluster,
* add node as block signer to this cluster. blockchain_configuration_signers update is included.
*/
function add_node_to_cluster_internal(provider, node, cluster) {
	if (exists( cluster_provider @* {cluster, provider})) {
		val nodes = cluster_node @* {cluster} .node;
		// for (n in nodes) {
		// 	require(n.provider != provider);
		// }
		create cluster_node(cluster, node);
		update_configuration_signers (cluster);
		print("blockchain configuration signers are updated");
	}
}

 enum container_type {
 	naked, // running directly on the node
 	isolated // container with resource limits
 }

 entity container {
 	key name;
 	index cluster;
 	container_type;
 	index deployer: voter_set; //  who can deploy and upsate bcs in this container
 }

 enum resource_limit_type {
 	cpu,
 	ram,
 	storage
 }

 entity cluster_resource_limit {
 	key cluster, resource_limit_type;
 	mutable value: integer;
 }

 entity container_resource_limit {
 	key container, resource_limit_type;
 	mutable value: integer;
 }

//Create cluster with deafult resource limits.
//Who can create a cluster? Any provider
operation create_cluster(me: provider, name, initials: list&lt;provider&gt;?, governance: voter_set, deployer: voter_set) {
	require_provider_auth_with_rl(me);
	val cl = create cluster(name, governance, deployer);
	create cluster_resource_limit(cl, resource_limit_type.cpu , 100);
	create cluster_resource_limit(cl, resource_limit_type.ram , 100);
	create cluster_resource_limit(cl, resource_limit_type.storage , 100);
	if (exists(initials)) {
		for (prov in initials) {
		create cluster_provider(cl, prov);			
		}
	}
}

 entity blockchain { key rid: byte_array; mutable active: boolean;}

 //Defines which container a blockchain belongs to
 entity container_blockchain { key container, blockchain; }
 
 // Cluster replicate this container, but container belongs to another cluster that is responsible for block building.
 entity cluster_container_replica { key cluster, container; }
 
 /*
  * For blockchain dependency tracking. Blockhain A (me) might be dependent on 
  * blockchain B (dependent_on). Dependency is not static; 
  * a bc can be different dependencies at different heights.
  */
 entity blockchain_dependency { key me: blockchain, height: integer, dependent_on: blockchain; }
 
 function add_dependencies(data: byte_array, me_brid: byte_array, height: integer) {
 	val config_map = map&lt;text, gtv&gt;.from_gtv(gtv.from_bytes(data));
	if (config_map.contains("dependencies")) {
		val deps = list&lt;(text, byte_array)&gt;.from_gtv(config_map["dependencies"]);   // Returns e.g.  [brid0, brid22, ..]
		for ((_, dep) in deps) {
			val dependent_on = blockchain @? { dep };
			if (exists(dependent_on)) {
				require(me_brid != dep);
				create blockchain_dependency( 
					me = blockchain @ {me_brid}, 
					dependent_on,
					height = height);	
			}
		}
	}
}

 function require_no_dependenices_on_me(blockchain) {
	require ( empty ( blockchain_dependency @* { .dependent_on == blockchain}));	
}
 
 </string>
                            </entry>
                            <entry key="directory1/common_module.rell">
                                <string>
entity provider { key pubkey; }

entity node {
	index provider;
	key pubkey;
	mutable active: boolean = true;
	mutable host: text;
	mutable port: integer;
	mutable api_port: integer; // NEW. Need API port to connect client to a node.
	mutable last_updated: timestamp;
}

object node_list {
	mutable last_update: timestamp = 0;
}

entity blockchain_added { key blockchain; key transaction; }

entity blockchain_configuration {
	key blockchain, height: integer;
	mutable data: byte_array;
}

entity blockchain_configuration_signers {
      key blockchain, height: integer;
      signers: byte_array;
}

entity blockchain_replica_node { key blockchain, node; }

function require_provider_auth (provider) { require( is_signer(provider.pubkey)); }

operation add_node (provider, node_pubkey: pubkey, host: text, port: integer, cluster?) {
	require_provider_auth_with_rl(provider);
	add_node_internal(provider, node_pubkey, host, port, cluster);
}

function add_node_internal(provider, node_pubkey: pubkey, host: text, port: integer, cluster?) {
	val existing_node = node @? { node_pubkey };
	if (exists(existing_node)) {
		require(existing_node.provider == provider);
		update existing_node (
			.active = true,
			.host = host,
			.port = port,
			.api_port = port,
			.last_updated = op_context.last_block_time
		);
	} else {
		create node (provider, node_pubkey, host, port=port, api_port=port,
			last_updated = op_context.last_block_time
		);
	}
	node_list.last_update = op_context.last_block_time;
	//If a cluster is given and provider is part of that cluster, add node as block signer to this cluster
	if (exists(cluster)) {
		add_node_to_cluster_internal(provider, node @ { node_pubkey }, cluster);
	}
}

operation remove_node (provider, node_pubkey: pubkey) {
	require_provider_auth_with_rl(provider);
	val node_to_remove = node @ { node_pubkey };
	node_to_remove.active = false;
	val clusters = cluster_node @* {.node.pubkey == node_pubkey} .cluster;
	delete cluster_node @* { .node.pubkey == node_pubkey };
	for (cl in clusters) {
	    //removing the last node of a cluster is not allowed:
	    require (not (empty (cluster_node @* { cl })));
        update_configuration_signers (cl);
	}
	node_list.last_update = op_context.last_block_time;
	//TODO: update blockchain_replica_node correspondingly?
}

function get_last_height (blockchain): integer {
	if (blockchain.rid == chain_context.blockchain_rid) {
		return op_context.block_height;
	} else {
		return (anchored_block @? { blockchain } (@sort_desc .height) limit 1) ?: -1;
	}
}

//Use this to update singers after a change in cluster_node table. TODO: +5 or not?
function update_configuration_signers (cluster) {
	val bcs = container_blockchain @*{ .container.cluster == cluster} .blockchain;
	for (blockchain in bcs) {
		val current_height =  get_last_height(blockchain);
		val container = container_blockchain @ {blockchain} .container;
		val signers = cluster_node @* { container.cluster } (@sort .node.pubkey);
		// do not write new configuration when size is 0 since it's impossible to recover
		// from that
		require(signers.size() &gt; 0);
		create blockchain_configuration_signers(blockchain, current_height + 5, signers.to_gtv().to_bytes());
	}
}

operation add_container_replica(me: provider, cluster, container) {
	require_provider_auth_with_rl(me);
	create cluster_container_replica(cluster, container);
}

operation remove_container_replica(me: provider, cluster, container) {
	require_provider_auth_with_rl(me);
	delete cluster_container_replica @ {cluster, container};
}

operation add_bc_replica (provider, blockchain, node) {
	require_provider_auth_with_rl(provider);
	require( node.provider == provider );			
	require(empty(blockchain_replica_node @? { blockchain, node }));
	create blockchain_replica_node ( blockchain, node );
}

operation remove_bc_replica (provider, blockchain, node) {
	require_provider_auth_with_rl(provider);
	require( node.provider == provider );		
	delete blockchain_replica_node @? { blockchain, node };
}</string>
                            </entry>
                            <entry key="directory1/common_queries.rell">
                                <string>
query get_provider (pubkey) = provider @ { pubkey };

query get_node (pubkey) = node @ { pubkey };

query get_container (name) = container @ { name };

query get_cluster (name) = cluster @ { name };

query get_node_data (pubkey) {
    return node @ {
        pubkey
    } (
        provider = .provider.pubkey,
        pubkey = .pubkey,
        active = .active,
        host = .host,
        port = .port,
        last_updated = .last_updated
    );
}

query get_blockchain (rid: byte_array) = blockchain @ { rid };

query get_nodes_by_provider(provider) {
    return node @* { provider } (
        .pubkey,
        .active,
        .host,
        .port,
        .last_updated
    );
}

query get_blockchain_signers(bc: blockchain) {
	val cl = container_blockchain @ {bc}.container.cluster;
	var return_list = list&lt;(byte_array, text, integer, boolean, integer)&gt;();
    if (bc.active) {
    	return_list = cluster_node @* { cl } (
        @sort .node.pubkey,
        .node.host,
        .node.port,
        .node.active,
        .node.last_updated
    	);
    }
    return return_list;
}

query get_blockchain_replicas(blockchain) {
    return blockchain_replica_node @* { blockchain } (
        .blockchain.rid,
        @sort .node.pubkey,
        .node.host,
        .node.port,
        .node.active,
        .node.last_updated
    );
}

query get_container_replicas(container) {
	return cluster_container_replica @* { container } (
		.cluster.name
	);
}

//Cannot use function get_last_height, since it uses an op_context.
query get_blockchain_last_height(blockchain) : integer {
	if (blockchain.rid == chain_context.blockchain_rid) {
		return  (block @? {} (@sort_desc .block_height) limit 1) ?: -1;
	} else {
		return (anchored_block @? { blockchain } (@sort_desc .height) limit 1) ?: -1;
	}
}

query get_blockchains(include_inactive: boolean): list&lt;byte_array&gt; {
	if (include_inactive) {
		return blockchain @* {} .rid;
	}
    return blockchain @* { .active == true } .rid;
}

query get_added_blockchain_rid(tx_rid: byte_array) {
	return blockchain_added @ { transaction @ { tx_rid } }.blockchain.rid;
}

query is_node (pubkey) : boolean {
	return not(empty(node @? { pubkey }));
	}

query get_voter_set (name) = voter_set @ { name };

query get_voter_set_members (name) {
	return voter_set_member @* {voter_set @ {name}} (.provider.pubkey);
}


query get_provider_points(pubkey): integer {
	return provider_rl_state @ {provider @ { pubkey }} .points;
}</string>
                            </entry>
                            <entry key="directory1/module.rell">
                                <string>@mount('')
module;

struct module_args {
    initial_provider: pubkey;
}

entity provider_state {
	key provider;
	mutable name: text;
	mutable active: boolean;
	mutable system: boolean; // NEW. System provider has extra permissions.
    mutable tier: integer; 	// NEW. Tier defines how much stuff provider can add. 0 is lowest.
}

// This operation will check that provider table is empty and if so add the provider supplied as module argument. And
// enable this first system provider.
operation init () {
	val tier = 1;
	require(empty( provider @* {}));
	create voter_set("SYSTEM", 1);
	/** System provider create a ‘system’ cluster which will include ‘system’ nodes and has a ‘system’ naked container 
	 * which will run the directory bc.
	 */
	val system_voter_set = create voter_set("SYSTEM_P", 0);
	val system_cluster = create cluster("system", governance=system_voter_set, deployer=system_voter_set, false);
	add_pubkey_as_provider(chain_context.args.initial_provider, true, tier, system_cluster);
	val prov = provider @ { chain_context.args.initial_provider};
	update provider_state @ { prov } ( .active = true );
	create voter_set_member(system_voter_set, prov);
	create provider_quota(tier, provider_quota_type.max_actions_per_day, value = 100);
	create container("system", system_cluster, container_type.naked, system_voter_set);
}


function add_pubkey_as_provider(pubkey, is_system: boolean, tier: integer, cluster?) {
	var enable = false;
	if (tier == 0) { enable = true; } //low rank providers can be enabled by anyone.
	val provider = create provider (pubkey);
		create provider_state (provider, name="",
			active=enable,
			system=is_system,
			tier=tier
		);
		create activity_counter (provider);
		create provider_rl_state(provider, points = 100, last_update=op_context.last_block_time);
		if (exists(cluster)) {
			create cluster_provider(cluster, provider);
		}
}

operation update_provider_data (provider, name?) {
	require_provider_auth_with_rl(provider);
	if (exists(name)) {
		update provider_state @ {provider} (
			.name = name
		);		
	}
}

//Includes enabling (active = true)
operation register_provider (me: provider, pubkey, tier: integer) {
	require_provider_auth_with_rl(me);
	require( (provider_state @ {me}.tier &gt; 0 and tier == 0) or (provider_state @ {me}.system));
	add_pubkey_as_provider(pubkey, false, tier, null);
}</string>
                            </entry>
                            <entry key="directory1/nm_api.rell">
                                <string>
query nm_get_peer_list_version() = node_list.last_update;

//Configuration updates are found in two tables. Both must be checked to get next configuration height.
query nm_find_next_configuration_height(
	blockchain_rid: byte_array,
	height: integer
	): integer?
{
		val bc = blockchain @? { blockchain_rid };
    	if (bc == null) return null;
    	val conf_h = blockchain_configuration @? { bc, .height &gt; height }
        	(@sort .height) limit 1;
        val sign_h = blockchain_configuration_signers @? { bc, .height &gt; height }
        	(@sort .height) limit 1;
        if (conf_h == null) return sign_h;
        if (sign_h == null) return conf_h;
        return max(conf_h, sign_h);
}

/** Merge content of blockchain_configuration and blockchain_configuration_signers */
query nm_get_blockchain_configuration(
	blockchain_rid: byte_array,
	height: integer
	): byte_array?
{
	val bc = blockchain @ { blockchain_rid };
    /* find configuration height -- the latest height up to given height
     * If conf_h exist, so does signer_h, thus no need to check both
     */
    val conf_h = blockchain_configuration @? { bc , .height &lt;= height } (@sort_desc .height) limit 1;
    if (conf_h != null)
        return blockchain_configuration_merge(bc, height, conf_h);
    else
        return null;
}

//checking that signers.size() is non-zero is done when population blockchain_configuration_signers. Thus, not needed to check here.
function blockchain_configuration_merge(blockchain, height: integer, conf_h: integer) : byte_array {
	val signer_h = blockchain_configuration_signers @ { blockchain , .height &lt;= height } (@sort_desc .height) limit 1;
	val signers = blockchain_configuration_signers @ {blockchain, .height==signer_h } .signers;
	val current_config = blockchain_configuration @ { blockchain, .height == conf_h };
	val config_dict = map&lt;text, gtv&gt;.from_gtv(gtv.from_bytes(current_config.data));
	config_dict["signers"] = gtv.from_bytes(signers);
	return config_dict.to_gtv().to_bytes();
}


/* Function getBlockchainsShouldBeLaunched() uses this query. If caller (nod_id) is a signer, return only active bcs.
 * Inactive bcs should not be launched, to alleviate block building.
 * If caller is a replica node of bc, include inactive bcs as well.
 */
query nm_compute_blockchain_list(node_id: pubkey): list&lt;byte_array&gt; {
	val node = node @? { .pubkey == node_id};

	if (exists(node)) {
		val clusters = cluster_node @* {node} .cluster;
		val res = list&lt;byte_array&gt;();
		res.add_all(blockchain_replica_node @* { node } (.blockchain.rid));
		for (cl in clusters) {
			val containers = container @*{ cl };
			for (container in containers) {
				res.add_all(container_blockchain @* {container, .blockchain.active == true} .blockchain.rid);
			}
		}
		return res;
	} else {
		return [chain_context.blockchain_rid];
	}
}

// note -- API expects array, so we need suppress naming
query nm_get_peer_infos () = node @* {} (_ = .host,_ = .port,_ = .pubkey,_ = .last_updated);

query nm_api_version () = 2;

query nm_get_blockchain_replica_node_map(blockchain_rids: list&lt;byte_array&gt;): list&lt;list&lt;byte_array&gt;&gt; {
	val res = list&lt;list&lt;byte_array&gt;&gt;();
	for (brid in blockchain_rids) {
		val bc = blockchain @? { brid };
		if (empty(bc)) {
			res.add(list&lt;byte_array&gt;());
		} else {
			// note: we include signers in this list because node processing old blocks might
			// want to connect to _current_ signers to get blocks
			val container = container_blockchain @ {bc} .container;
			val signers = set( cluster_node @* { container.cluster } .node.pubkey );
			signers.add_all(
				blockchain_replica_node @* { bc } .node.pubkey
			);
			res.add(list(signers));
		}
	}
	return res;
}

//Function used by  mustSyncUntil (height) pos-146
query nm_get_blockchain_last_height_map(blockchain_rids: list&lt;byte_array&gt;) : list&lt;integer&gt; {
	val res = list&lt;integer&gt;();
    for (brid in blockchain_rids) {
    		val bc = blockchain @? { brid };
    		if (brid == chain_context.blockchain_rid) {
    			val h = (block @? {} (@sort_desc .block_height) limit 1) ?: -1;
    		    res.add( h );
    		} else if (empty(bc)) {
            	res.add(-1);
            } else {
            	val h = (anchored_block @? { bc } (@sort_desc .height) limit 1) ?: -1;
                res.add( h );
            }
    }
    return res;
}

query nm_get_node_replica_map(): list&lt;list&lt;byte_array&gt;&gt; {
	return list&lt;list&lt;byte_array&gt;&gt;();
}

query nm_get_container_limits (name) : map&lt;text, integer&gt; {
	val container = container @ {name};
	var return_map = map&lt;text, integer&gt;();
	val limits_list = container_resource_limit @* {container};
	for (l in limits_list) {
		val r = l.resource_limit_type;
		return_map.put(r.name, l.value);
	}
	return return_map;
}

query nm_get_cluster_limits (name) : map&lt;text, integer&gt; {
	val cluster = cluster @ {name};
	var return_map = map&lt;text, integer&gt;();
	val limits_list = cluster_resource_limit @* {cluster};
	for (l in limits_list) {
		val r = l.resource_limit_type;
		return_map.put(r.name, l.value);
	}
	return return_map;
}

query nm_get_containers(pubkey): list&lt;text&gt; {
	val clusters = cluster_node @* {node @ { pubkey }} .cluster;
	val res = list&lt;text&gt;();
	for (cl in clusters) {
		val containers = container @* {cl} .name;
		res.add_all(containers);
	}
	return res;
}

query nm_get_blockchains_for_container(container_name: text): list&lt;byte_array&gt; {
	val container = container @? {container_name};
	val res = list&lt;byte_array&gt;();
	if (exists(container)) {
		val cluster = container.cluster;
		res.add_all(container_blockchain @* {container, .blockchain.active == true} .blockchain.rid);
	}
	return res;
}

//Returns a list of brids with corresponding container that this blockchain is dependent on. At the given height.
query nm_get_blockchain_dependencies(blockchain, height: integer): list&lt;(byte_array, text)&gt; {
	val res = list&lt;(byte_array, text)&gt;();
	val conf_h = blockchain_configuration @? { blockchain, .height &lt;= height }
        	(@sort .height) limit 1;
    if (conf_h != null) {
    	val brids = blockchain_dependency @* {.me == blockchain, conf_h} .dependent_on.rid;
    	for (brid in brids) {
    		res.add((brid, container_blockchain @ { blockchain @{brid}} .container.name));
    	}
    }
	return res;
}</string>
                            </entry>
                            <entry key="directory1/propose_apply.rell">
                                <string>
 enum proposal_type {
   conf,
   bc,
   container,
   container_limits,
   cluster_limits,
   cluster_provider,
   voter_set_provider,
   provider_state,
   provider_is_system,
   bc_pause,
   bc_unpause,
   bc_delete
   // and a lot more
}

entity proposal {
  index timestamp, proposal_type;
  proposed_by: provider;
  index voter_set; // voter set is determined at the time proposal is created
}


//Proposed configuration changes are put here while waiting for enough positive votes.
entity pending_conf {
    key proposal;
    blockchain;
	height: integer;
	force: boolean;
    data: byte_array;
}

entity pending_container {
	key proposal;
	key name;
 	cluster;
 	container_type;
 	deployer: voter_set;
}

entity pending_container_limits {
	key proposal;
	key container;
	cpu: integer;
	ram: integer;
	storage: integer;
}

entity pending_cluster_limits {
	key proposal;
	key cluster;
	cpu: integer;
	ram: integer;
	storage: integer;
}

entity pending_cluster_provider {
	key proposal;
	key cluster;
	provider;
	add: boolean;
}

entity pending_voter_set_provider {
	key proposal;
	key voter_set;
	provider;
	add: boolean;
}

//Proposed destructions of bcs are put here while waiting for enough positive votes.
entity pending_delete_blockchain {
    key proposal;
    key blockchain;
}

//Proposed pauses of bcs are put here while waiting for enough positive votes.
entity pending_pause_blockchain {
    key proposal;
    key blockchain;
}

//Proposed unpauses (start building blocks again) of bcs are put here while waiting for enough positive votes.
entity pending_unpause_blockchain {
    key proposal;
    key blockchain;
}

//Proposed bc:s are put here while waiting for enough positive votes.
entity pending_blockchain {
	key proposal;
	data: byte_array;
	container;
}

//Proposed enabling/disabling of providers are put here while waiting for enough positive votes.
entity pending_provider_state {
	key proposal;
	provider;
	active: boolean;
}

//Proposed promotion/demotion of provider to/from being system provider
entity pending_provider_is_system {
	key proposal;
	provider;
	system: boolean;
}

//Who can create a new container? Cluster deployers' voter set. (They can also update container limits.)
operation propose_container(me: provider, cluster, name, deployer: voter_set) {
	//check that provider authority and that it is cluster's deployer
	require_provider_auth_with_rl(me);
	require_cluster_deployer(cluster, me);
	val prop = create proposal(op_context.last_block_time, proposal_type.container, me, cluster.deployer);
	create pending_container(prop, name, cluster, container_type.isolated, deployer);
	internal_vote( me, prop, true );
}

//Who can update container limits? Cluster deployers' voter set.
operation propose_container_limits(me: provider, container, ram: integer, cpu: integer, storage: integer) {
	//check that provider authority and that it is cluster's deployer
	require_provider_auth_with_rl(me);
	require_cluster_deployer(container.cluster, me);
	val prop = create proposal(op_context.last_block_time, proposal_type.container_limits, me, container.cluster.deployer);
	create pending_container_limits(prop, container, cpu, ram, storage);
	internal_vote( me, prop, true );
}

//Who can update cluster limits? Cluster governance voter set.
operation propose_cluster_limits(me: provider, cluster, ram: integer, cpu: integer, storage: integer) {
	//check that provider authority and that it is a cluster governor
	require_provider_auth_with_rl(me);
	require_cluster_governor(cluster, me);
	val prop = create proposal(op_context.last_block_time, proposal_type.cluster_limits, me, cluster.governance);
	create pending_cluster_limits(prop, cluster, cpu, ram, storage);
	internal_vote( me, prop, true );
}

//Who can update voter set's provider list? Voter set's governor.
operation propose_voter_set_provider(me: provider, voter_set, provider, add: boolean) {
	//check that provider authority and that it is a cluster governor
	require_provider_auth_with_rl(me);
	require_voter_set_governor(voter_set, me);
	val governor = voter_set_governance @ { voter_set } .governor;
	val prop = create proposal(op_context.last_block_time, proposal_type.voter_set_provider, me, governor);
	create pending_voter_set_provider(prop, voter_set, provider, add);
	internal_vote( me, prop, true );
}

//Who can update cluster provider list? Cluster governance voter set.
operation propose_cluster_provider(me: provider, cluster, provider, add: boolean) {
	//check that provider authority and that it is a cluster governor
	require_provider_auth_with_rl(me);
	require_cluster_governor(cluster, me);
	val prop = create proposal(op_context.last_block_time, proposal_type.cluster_provider, me, cluster.governance);
	create pending_cluster_provider(prop, cluster, provider, add);
	internal_vote( me, prop, true );
}


//Who can propose a new blockchain? The container deployer voter set
operation propose_blockchain( me: provider, config_data: byte_array, container) {
	require_provider_auth_with_rl(me);
	require_container_deployer(container, me);
	//If already proposed, do not add again.
	if (empty(pending_blockchain @* {.data == config_data } limit 1)) {
		val prop = create proposal(op_context.last_block_time, proposal_type.bc, me, container.deployer);
		create pending_blockchain(prop, config_data, container);
		internal_vote( me, prop, true );
	}
}


//Pubkey used for authorization. Who can propose configuration updates? Container deployers.
//SYSTEM_P is deployer of system container
operation propose_configuration (blockchain, me: provider, config_data: byte_array, height: integer, force: boolean) {
	require_provider_auth_with_rl(me);
	val container = container_blockchain @ {blockchain} .container;
	require_container_deployer(container, me);
	require(get_last_height(blockchain) &lt; height);
	if (not(force)) {
		require(empty(blockchain_configuration @? { blockchain, .height &gt;= height } limit 1));
		require(empty(pending_conf @? { blockchain, .height &gt;= height } limit 1));
	}
	val prop = create proposal(op_context.last_block_time, proposal_type.conf, me, container.deployer);
	create pending_conf(prop,
		blockchain,
		height,
		force,
		data = config_data
	);
	internal_vote(me, prop, true);
}

//Who can pause, unpause and delete bcs? Container deployers
operation propose_pause_blockchain(me: provider, blockchain) {
	require_provider_auth_with_rl (me);
	val container = container_blockchain @ {blockchain} .container;
	require_container_deployer(container, me);
	val prop = create proposal(op_context.last_block_time, proposal_type.bc_pause, me, container.deployer);
	create pending_pause_blockchain(prop, blockchain);
	internal_vote(me, prop, true);
}

//Who can pause, unpause and delete bcs? Container deployers
operation propose_unpause_blockchain(me: provider, blockchain) {
	require_provider_auth_with_rl (me);
	val container = container_blockchain @ {blockchain} .container;
	require_container_deployer(container, me);
	val prop = create proposal(op_context.last_block_time, proposal_type.bc_unpause, me, container.deployer);
	create pending_unpause_blockchain(prop, blockchain);
	internal_vote(me, prop, true);
}

//Who can pause and delete bcs? Container deployers
//NB not Ok to delete a bc if other bcs dependend on it.
operation propose_delete_blockchain(me: provider, blockchain) {
	require_no_dependenices_on_me(blockchain);
	require_provider_auth_with_rl (me);
	val container = container_blockchain @ {blockchain} .container;
	require_container_deployer(container, me);
	val prop = create proposal(op_context.last_block_time, proposal_type.bc_delete, me, container.deployer);
	create pending_delete_blockchain(prop, blockchain);
	internal_vote(me, prop, true);
}

//Who can enable providers with tier=0? Any existing provider with tier &gt; 0.
//Who can enable providers with tier &gt; 0? SYSTEM_P voter set.
operation propose_enable_provider(me: provider, other_prov: provider) {
	require_provider_auth_with_rl(me);
	if (provider_state @ {other_prov}.tier == 0 and provider_state @ {me}.tier &gt; 0) {
		update_provider_state(other_prov, true);		
	} else {
		require_system_p_member(me);
		//If proposal already exist, do not add again.
		if (empty(pending_provider_state @* { .provider == other_prov, .active == true } limit 1)) {
			val system_voter_set = voter_set @ {"SYSTEM_P"};
			val prop = create proposal(op_context.last_block_time, proposal_type.provider_state, me, system_voter_set);
			create pending_provider_state(prop, other_prov, .active = true);
			internal_vote( me, prop, true);
		}
	}
}

//Who can disable provider? SYSTEM_P voter set.
operation propose_disable_provider(me: provider, other_prov: provider) {
	require_provider_auth_with_rl(me);
	require_system_p_member(me);
	if (empty(pending_provider_state @* { .provider == other_prov, .active == false } limit 1)) {
		val system_voter_set = voter_set @ {"SYSTEM_P"};
		val prop = create proposal(op_context.last_block_time, proposal_type.provider_state, me, system_voter_set);
		create pending_provider_state(prop, other_prov, .active = false);
		internal_vote( me, prop, true);
	}
}

//Who can promote/demote a provider? SYSTEM_P voter set.
operation propose_provider_is_system(me: provider, other_prov: provider, promote: boolean) {
	print("propose_provider_is_system");
	require_provider_auth_with_rl(me);
	require_system_p_member(me);
	//If proposal already exist, do not add again.
	if (empty(pending_provider_is_system @* { .provider == other_prov, .system == promote } limit 1)) {
		val system_voter_set = voter_set @ {"SYSTEM_P"};
		val prop = create proposal(op_context.last_block_time, proposal_type.provider_is_system, me, system_voter_set);
		create pending_provider_is_system(prop, other_prov, .system = promote);
		internal_vote( me, prop, true);
	}
}

function apply_voting_result (prop: proposal) {
	print("consensus?");
	if (consensus_achieved(prop)) {
		print("approval achieved");
		when (prop.proposal_type) {
	 		conf              -&gt; apply_conf(prop);
	 		bc                -&gt; apply_bc(prop);
			container         -&gt; apply_container(prop);
			container_limits  -&gt; apply_container_limits(prop);
			cluster_limits    -&gt; apply_cluster_limits(prop);
			cluster_provider  -&gt; apply_cluster_provider(prop);
			voter_set_provider-&gt; apply_voter_set_provider(prop);
			provider_state    -&gt; apply_provider_state(prop);
			provider_is_system-&gt; apply_provider_is_system(prop);
			bc_pause		  -&gt; apply_pause_blockchain(prop);
			bc_unpause		  -&gt; apply_unpause_blockchain(prop);
			bc_delete		  -&gt; apply_delete_blockchain(prop);
	}
		val prop_id = vote @* {.proposal == prop} (.rowid);
		delete vote @* {.proposal == prop};
		delete proposal @ {.rowid == prop.rowid};
	} else if (proposal_rejected(prop)) {
		print("proposal has been rejected");
		when (prop.proposal_type) {
	 		conf              -&gt; delete pending_conf @ { prop };
	 		bc                -&gt; delete pending_blockchain @ { prop };
			container         -&gt; delete pending_container @ { prop };
			container_limits  -&gt; delete pending_container_limits @ { prop };
			cluster_limits    -&gt; delete pending_cluster_limits @ { prop };
			cluster_provider  -&gt; delete pending_cluster_provider @ { prop };
			voter_set_provider-&gt; delete pending_voter_set_provider @ { prop };
			provider_state    -&gt; delete pending_provider_state @ { prop };
			provider_is_system-&gt; delete pending_provider_is_system @ { prop };
			bc_pause		  -&gt; delete pending_pause_blockchain @ { prop };
			bc_unpause		  -&gt; delete pending_unpause_blockchain @ { prop };
			bc_delete		  -&gt; delete pending_delete_blockchain @ { prop };
	}
		val prop_id = vote @* {.proposal == prop} (.rowid);
		delete vote @* {.proposal == prop};
		delete proposal @ {.rowid == prop.rowid};
	} else {
		print("no, not yet");
	}
}

//Apply decision on creation of new container. With default resource limits.
//TODO: Update default values to make sense.
function apply_container(proposal) {
	val pps = pending_container @ {proposal};
	val c = create container(pps.name, pps.cluster, pps.container_type, pps.deployer);
	create container_resource_limit(c, resource_limit_type.cpu , 100);
	create container_resource_limit(c, resource_limit_type.ram , 100);
	create container_resource_limit(c, resource_limit_type.storage , 100);
	delete pending_container @ { proposal };
}

function apply_container_limits(proposal) {
	val pps = pending_container_limits @ {proposal};
	update container_resource_limit @ {pps.container, resource_limit_type.ram} (pps.ram);
	update container_resource_limit @ {pps.container, resource_limit_type.cpu} (pps.cpu);
	update container_resource_limit @ {pps.container, resource_limit_type.storage} (pps.storage);
	delete pending_container_limits @ { proposal };
}

function apply_cluster_limits(proposal) {
	val pps = pending_cluster_limits @ {proposal};
	update cluster_resource_limit @ {pps.cluster, resource_limit_type.ram} (pps.ram);
	update cluster_resource_limit @ {pps.cluster, resource_limit_type.cpu} (pps.cpu);
	update cluster_resource_limit @ {pps.cluster, resource_limit_type.storage} (pps.storage);
	delete pending_cluster_limits @ { proposal };
}

function apply_cluster_provider(proposal) {
	val pps = pending_cluster_provider @ {proposal};
	if (pps.add) {
		create cluster_provider(pps.cluster, pps.provider);
	} else {
		delete cluster_provider @ {pps.cluster, pps.provider};
	}
	delete pending_cluster_provider @ { proposal };
}

function apply_voter_set_provider(proposal) {
	val pps = pending_voter_set_provider @ {proposal};
	if (pps.add) {
		create voter_set_member(pps.voter_set, pps.provider);
	} else {
		delete voter_set_member @ {pps.voter_set, pps.provider};
	}
	delete pending_voter_set_provider @ { proposal };
}


//For promotion and demotion of system providers
function apply_provider_is_system(proposal) {
	val pps = pending_provider_is_system @ {proposal};
	update provider_state @ { pps.provider } ( .system = pps.system );

	//If promotion, update SYSTEM_P voter set
	if (provider_state @ { pps.provider }.system) {
		create voter_set_member(voter_set @ {"SYSTEM_P"}, pps.provider);
	} else {
		delete voter_set_member @? {.voter_set == voter_set @ {"SYSTEM_P"}, .provider == pps.provider};
	}
	delete pending_provider_is_system @ { proposal };
}

//For both enabling and disabling of providers:
function apply_provider_state(proposal) {
	val pps = pending_provider_state @ {proposal};
	update_provider_state(pps.provider, pps.active);
	delete pending_provider_state @ { proposal };
}

function update_provider_state(provider, active: boolean) {
	update provider_state @ { provider } ( .active = active );
	if (active == false) {
		update node @* { provider } ( .active = false );
		for (cl in cluster_provider @* { .provider == provider } (.cluster)) {
			for (n in node @* { provider }) {
				delete cluster_node @* { n };
			}
			update_configuration_signers(cl);
		}
		node_list.last_update = op_context.last_block_time;
		//remove disabled provider from voter_set_member table
		delete voter_set_member @* { .provider == provider};
		//TODO: Delete all replicas of the provider?
		delete blockchain_replica_node @* { .node.provider == provider };
	} else { //enable
		//If enabled provider is a system provider, update SYSTEM_P voter set
		if (provider_state @ { provider }.system) {
			create voter_set_member(voter_set @ {"SYSTEM_P"}, provider);
		}
	}
}

function apply_conf(proposal) {
	val pc = pending_conf @ {proposal};
	require(get_last_height(pc.blockchain) &lt; pc.height);
	if (not(pc.force)) {
		require(empty(blockchain_configuration @? { pc.blockchain, .height &gt; pc.height } limit 1));
	}
	if (not(exists(blockchain_configuration @? {pc.blockchain, pc.height} ))) {
		create blockchain_configuration(
			pc.blockchain,
			pc.height,
			data = pc.data
		);
		add_dependencies(pc.data, pc.blockchain.rid, pc.height);
	} else {
		update blockchain_configuration @ { pc.blockchain, pc.height }(.data = pc.data);
	}
	delete pending_conf @* { proposal };
}

//Initial signers of new bc are the ones in cluster_node table.
function apply_bc(proposal) {
	val bc = pending_blockchain @ {proposal};
	val config = map&lt;text, gtv&gt;.from_gtv(gtv.from_bytes(bc.data));
	val blockchain_rid = config.hash();
	val blockchain = create blockchain ( blockchain_rid, true );
	print("Added blockchain", blockchain_rid);
	create blockchain_configuration (blockchain, 0, bc.data);
	val signers = cluster_node @* { bc.container.cluster } (@sort .node.pubkey);
	// do not write new configuration when size is 0 since it's impossible to recover
	// from that.
	require(signers.size() &gt; 0);
	create blockchain_configuration_signers(blockchain, 0, signers.to_gtv().to_bytes());
	create blockchain_added (blockchain, op_context.transaction);
	create container_blockchain(bc.container, blockchain);
	add_dependencies(bc.data, blockchain_rid, 0);
	delete pending_blockchain @* { proposal };
}


//remove block production by inactivating bc, Keep replicas.
function apply_pause_blockchain(proposal) {
	val bc = pending_pause_blockchain @ { proposal };
	update blockchain @ { bc.blockchain.rid } (.active = false);
	/* val cl = container_blockchain @ {bc.blockchain}.container.cluster;
	for (n in cluster_node @* {.cluster == cl} .node) {
		create blockchain_replica_node(bc.blockchain, n);	
	} */
	delete pending_pause_blockchain @ { proposal };
}

/* restart block production (activate bc), block builders will be the ones in cluster_node.
 * cluster nodes are removed from blockchain_replica_node table. To ensure that signers 
are not also replicas.
* 
*/
function apply_unpause_blockchain(proposal) {
	val bc = pending_unpause_blockchain @ { proposal };
	update blockchain @ { bc.blockchain.rid } (.active = true);
	val cl = container_blockchain @ {bc.blockchain}.container.cluster;
	for (n in cluster_node @* {.cluster == cl} .node) {
		delete blockchain_replica_node @? {bc.blockchain, n};	
	}
	delete pending_unpause_blockchain @ { proposal };
}

//Delete everything about this bc.
function apply_delete_blockchain(proposal) {
	val bc = pending_delete_blockchain @ { proposal } .blockchain;
	delete container_blockchain @ { bc };
	delete blockchain_configuration @* { bc };
	delete blockchain_configuration_signers @* { bc };
	delete blockchain_added @* { bc };
	delete blockchain_replica_node @* { bc };
	delete blockchain_dependency @* { .me == bc };
	delete pending_delete_blockchain @ { proposal };
	delete blockchain @ { bc.rid };
}</string>
                            </entry>
                            <entry key="directory1/provider_limitation.rell">
                                <string>

// type of quota for a provider
enum provider_quota_type {
	max_nodes,
	max_actions_per_day
}

entity provider_quota {
	index tier: integer, provider_quota_type;
	mutable value: integer;
}

// Limit how much stuff provider can do to prevent abuse,
// such as starting billion nodes, etc.
entity provider_rl_state {
	key provider;
	mutable points: integer;
	mutable last_update: integer;
}

// recover provider's action points and consume one, if possible
function provider_rate_limit (provider) {
	val max_actions_per_day = provider_quota @ {
			.tier == provider_state @ { provider } .tier,
			provider_quota_type.max_actions_per_day
	} .value;

	// We recover max_actions_per_day in 24 hours, find time needed to recover 1 point
	val recovery_time = (86400 * 1000) / max_actions_per_day;
    val state = provider_rl_state @ { provider } (.points, .last_update);
    val time_delta = op_context.last_block_time - state.last_update;
    var got_points = 0;
    var update_time = state.last_update;

    if (time_delta &gt; recovery_time)
    {
        got_points = time_delta / recovery_time;
        // advance  update_time to a multiple of recovery_time to avoid wasting time
        update_time = state.last_update + got_points * recovery_time;
        if (got_points + state.points &gt; max_actions_per_day) {
            got_points = max_actions_per_day - state.points;
            // if user is at the maximum reset his timer
            update_time = op_context.last_block_time;
        }
    }

    require(state.points + got_points &gt; 0); // make sure we have at least one point, which will be spent

    update provider_rl_state @ { provider } (
        .points += got_points - 1,
        .last_update = update_time
    );
}

// This is the function we should use for auth
function require_provider_auth_with_rl (provider) {
	require_provider_auth(provider);
	provider_rate_limit(provider);
}


operation transfer_action_points (from: provider, to: provider, amount: integer) {
	require_provider_auth_with_rl(from);
	require( provider_rl_state @ { from } .points &gt;= amount);
	update provider_rl_state @ { from } ( .points -= amount );
	update provider_rl_state @ { to } ( .points += amount );
}

function require_cluster_deployer(cluster, provider) {
	require_voter_set_member(cluster.deployer, provider);	
}

function require_system_p_member(provider) {
	require_voter_set_member(voter_set @ {"SYSTEM_P"}, provider);	
}

function require_cluster_governor(cluster, provider) {
	require_voter_set_member(cluster.governance, provider);
}

function require_voter_set_governor(voter_set, provider) {
	val governor = voter_set_governance @ { voter_set } .governor;
	require_voter_set_member(governor, provider);
}

function require_container_deployer(container, provider) {
	require_voter_set_member(container.deployer, provider);
}

function require_voter_set_member(voter_set, provider) {
	require ( exists ( voter_set_member @* { voter_set, provider}));	
}
</string>
                            </entry>
                            <entry key="directory1/queries.rell">
                                <string>

query get_provider_data (pubkey) {
    return provider_state @ {
        provider @ { pubkey }
    } (
        pubkey = .provider.pubkey,
        name = .name,
        active = .active
    );
}



query get_all_providers() {
    return provider_state @* {} (
        pubkey = .provider.pubkey,
        name = .name,
        active = .active
    );
}

query get_nodes_with_provider() {
    return (node, provider_state) @* { node.provider == provider_state.provider } (
        pubkey = .pubkey,
        node_active = node.active,
        host = .host,
        port = .port,
        last_updated = .last_updated,
        name = .name,
        provider_active = provider_state.active,
        provider = node.provider.pubkey
    );
}

query enterprise_solution_version() = "0.1";

//queries used in the voting procedure for configuration updates:
query get_proposals_since (since: rowid) {
  return proposal @* {  .rowid &gt; since } (.rowid, .proposal_type) limit 10;
}

query get_proposal (rowid) {
  return proposal @{  rowid }
  (
        proposed_by = .proposed_by.pubkey,
        timestamp = .timestamp,
        proposal_type = .proposal_type,
        rowid = .rowid
    );
}
</string>
                            </entry>
                            <entry key="directory1/voting.rell">
                                <string>entity voter_set {
    key name;
    mutable threshold: integer = 0;
	// special values for threshold:
	// 	0: supermajority of voters, specifically  `n - (n - 1) / 3` (which is usually around 67%)
	// -1: simple majority
	// positive number: that many voters
}

// Who is allowed to change a voter set?
// If not defined, it is the voter set itself
entity voter_set_governance {
	key voter_set;
	index governor: voter_set;
}

entity voter_set_member {
    key voter_set, provider;
}
/* Governance semantics:
 *
 * Anybody can create a new voter_set directly, but it consumes an action point.
 * voter_set can be updated. if voter_set_goverance is defined, it will control voter set, otherwise, it is the voter set itself
 * */
 operation create_voter_set(me: provider, name, threshold: integer, initials: list&lt;provider&gt;?, govenor: voter_set?) {
 	require_provider_auth_with_rl(me);
 	val vs = create voter_set(name, threshold);
 	if (exists(govenor)) {
 		create voter_set_governance(voter_set=vs, governor=govenor);
 	}
 	 if (exists(initials)) {
 		for (prov in initials) {
 			create voter_set_member(voter_set=vs, prov);	
 	 	}
 	}
 }

entity vote {
    key proposal, provider;
	ok: boolean; //here we see if the signer voted yes or no
}

//NB: check authority before calling this function
function internal_vote (provider, prop: proposal, ok: boolean) {
	create vote(prop, provider, ok);
	print("vote added");
	apply_voting_result(prop);
}

//Pubkey used for authorization
operation make_vote(provider, prop: proposal, ok: boolean) {
	require_provider_auth_with_rl(provider);
	require(not(empty(voter_set_member @* {prop.voter_set, provider})));
	print("vote authorization OK");
	require(empty(vote @? {prop, provider})); //only one vote per pubkey.
	internal_vote( provider, prop, ok);
}


function max_votes(voter_set) { return voter_set_member @* { voter_set } (@sum 1) limit 1;}
function positive_votes(proposal) { return vote @* {proposal, .ok == true }; }
function negative_votes(proposal) { return vote @* {proposal, .ok == false }; }

function needed_votes(voter_set) {
	val n = max_votes(voter_set);
	print("max votes:", n);
	var needed_votes = voter_set.threshold;
	//Two special cases (0 and -1):
	when (voter_set.threshold) {
		0  -&gt; needed_votes = n[0] - (n[0]-1)/3;
	 	-1 -&gt; needed_votes = n[0]/2+1;	 		
	 }
	 print("needed votes:", needed_votes);
	 return needed_votes;
}

function consensus_achieved (proposal) {
	if (exists(positive_votes(proposal))) {
		val nof_votes = vote @* { .proposal == proposal, .ok == true} ( @sum 1 );
		print("positive votes:", nof_votes);
		return ((nof_votes[0] &gt;= needed_votes(proposal.voter_set)));
	}
	print("No positive votes");
	return false; 
}

function proposal_rejected (proposal) {
	if (exists(negative_votes(proposal))) {		
		val nof_votes = vote @* { .proposal == proposal, .ok == false} ( @sum 1 );
		print("negative votes:", nof_votes);
		return ((nof_votes[0] &gt;= needed_votes(proposal.voter_set)));
	}
	print("No negative votes");
	return false;	
}
</string>
                            </entry>
                        </dict>
                    </entry>
                    <entry key="version">
                        <string>0.10.4</string>
                    </entry>
                </dict>
            </entry>
        </dict>
    </entry>
    <entry key="signers">
        <array>
            <bytea>{{ node0.pubkey}}</bytea>
        </array>
    </entry>
</dict>
